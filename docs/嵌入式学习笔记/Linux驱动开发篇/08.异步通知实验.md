## 说明

感觉异步通知就像主动触发一个函数执行。

## 驱动编程

使用异步通知的时候，需要提供相应的`.fasync`的函数，来实现获得异步通知在应用层设置的相关参数，异步通知相关代码如下。

```C
struct fasync_struct *button_fasync;

static int gpio_key_drv_fasync(int fd, struct file *file, int on)
{
	if (fasync_helper(fd, file, on, &button_fasync) >= 0)
		return 0;
	else
		return -EIO;
}

/* 定义自己的file_operations结构体                                              */
static struct file_operations gpio_key_drv = {
	.owner	 = THIS_MODULE,
	.read    = gpio_key_drv_read,
    .poll    = gpio_key_drv_poll,
    .fasync  = gpio_key_drv_fasync,
};
```

这个里面的`fasync_helper`函数的作用，会分配构造一个 `fasync_struct` 结构体 `button_async`。该结构体，

```C
//在驱动文件的 flag 被设置为 FAYNC 时
button_async->fa_file = filp; // filp 表示驱动程序文件，里面含有之前设置的 PID
//驱动文件被设置为非 FASYNC 时
button_async->fa_file = NULL;
```

以后想发送信号时，使用 button_async 作为参数就可以，它里面“可能”含有 PID。

然后我们就可以在例如中断服务函数中发送信号。

```C
static irqreturn_t gpio_key_isr(int irq, void *dev_id)
{
	struct key_dev *gpio_key = dev_id;
	int val;
	val = gpiod_get_value(gpio_key->gpiod);
	
	printk("key %d %d\n", gpio_key->gpio, val);	
    g_key = (gpio_key->gpio << 8) | val;
    wake_up_interruptible(&gpio_key_wait);
    kill_fasync(&button_fasync, SIGIO, POLL_IN);
	return IRQ_HANDLED;
}
```

## 应用编程

应用编程一般有以下几步

1.编写信号处理函数
2.注册信号处理函数
3.打开驱动
4.把进程 PID 告诉驱动
5.使能驱动的 FASYNC 功能

```C

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <poll.h>
#include <signal.h>

static int fd;
//1.编写信号处理函数
static void sig_func(int sig)
{
	int val;
	read(fd, &val, 4);
	printf("get button : 0x%x\n", val);
}

/*
 * ./button_test /dev/100ask_button0
 *
 */
int main(int argc, char **argv)
{
	int val;
	struct pollfd fds[1];
	int timeout_ms = 5000;
	int ret;
	int	flags;
	
	if (argc != 2) 
	{
		printf("Usage: %s <dev>\n", argv[0]);
		return -1;
	}
	//2.注册信号处理函数
	signal(SIGIO, sig_func);
	//3.打开驱动
	fd = open(argv[1], O_RDWR);
	if (fd == -1)
	{
		printf("can not open file %s\n", argv[1]);
		return -1;
	}
	//4.把进程 PID 告诉驱动
	fcntl(fd, F_SETOWN, getpid());
	//5.使能驱动的 FASYNC 功能
	flags = fcntl(fd, F_GETFL);
	fcntl(fd, F_SETFL, flags | FASYNC);

	while (1)
	{
		printf("www.100ask.net \n");
		sleep(2);
	}
	
	close(fd);
	
	return 0;
}
```